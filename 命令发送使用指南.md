# 🔧 机器人命令发送使用指南

## 📋 概述

现在我们已经有了完整的WebSocket通信系统，包括服务器端和客户端。本指南介绍如何向连接的机器人发送控制命令。

## 🚀 启动系统

### 1. 启动WebSocket服务器

```bash
python3 simple_websocket_server.py
```

服务器启动后会显示：
```
🚀 启动简化WebSocket服务器...
📡 监听端口: 8001
🔗 机器人连接地址: ws://localhost:8001/robot/{robot_id}
==================================================
✅ WebSocket服务器启动成功
⏳ 等待机器人连接...
```

### 2. 启动机器人客户端（同事那边）

```bash
python3 robot_test_client.py
```

## 🔧 发送命令的方法

### 方法1: 集成命令发送（推荐）

WebSocket服务器已经集成了命令发送功能。当机器人连接后，服务器会自动显示命令菜单：

```
🤖 已连接的机器人: ['1']
📋 可用命令:
  - open_door: 开门
  - close_door: 关门
  - start_delivery: 开始配送
  - stop_robot: 停止机器人
  - emergency_open_door: 紧急开门
  - 输入 'help' 查看帮助
  - 输入 'status' 查看机器人状态
  - 输入 'quit' 退出

请输入命令 (格式: 机器人ID 命令):
```

**使用示例**：
```
1 open_door          # 向机器人1发送开门命令
1 close_door         # 向机器人1发送关门命令
1 start_delivery     # 向机器人1发送开始配送命令
1 stop_robot         # 向机器人1发送停止命令
1 emergency_open_door # 向机器人1发送紧急开门命令
```

### 方法2: 独立命令发送脚本

使用 `send_command.py` 脚本：

```bash
python3 send_command.py <服务器地址> <机器人ID> <命令>
```

**使用示例**：
```bash
# 向本地服务器的机器人1发送开门命令
python3 send_command.py ws://localhost:8001/robot/1 1 open_door

# 向远程服务器的机器人2发送关门命令
python3 send_command.py ws://192.168.1.100:8001/robot/2 2 close_door

# 向机器人1发送开始配送命令
python3 send_command.py ws://localhost:8001/robot/1 1 start_delivery
```

### 方法3: 编程方式发送命令

```python
import asyncio
import websockets
import json

async def send_robot_command(server_url, robot_id, command):
    """发送机器人命令"""
    async with websockets.connect(server_url) as websocket:
        command_message = {
            "type": "command",
            "command": command,
            "command_id": f"cmd_{int(time.time())}",
            "target_robot": robot_id,
            "timestamp": time.time()
        }
        
        await websocket.send(json.dumps(command_message))
        print(f"✅ 命令已发送: {command} -> 机器人 {robot_id}")

# 使用示例
asyncio.run(send_robot_command("ws://localhost:8001/robot/1", "1", "open_door"))
```

## 📋 可用命令列表

| 命令 | 描述 | 示例 |
|------|------|------|
| `open_door` | 开门 | 打开机器人舱门 |
| `close_door` | 关门 | 关闭机器人舱门 |
| `start_delivery` | 开始配送 | 开始配送任务 |
| `stop_robot` | 停止机器人 | 停止机器人移动 |
| `emergency_open_door` | 紧急开门 | 紧急情况下开门 |

## 🔍 查看机器人状态

### 在服务器端查看

当机器人连接后，在服务器端输入：
```
status
```

会显示所有连接机器人的状态：
```
🤖 机器人 1: {
  "connected": true,
  "connected_at": "2024-01-01T12:00:00",
  "last_heartbeat": "2024-01-01T12:05:00"
}
```

### 查看帮助

在服务器端输入：
```
help
```

会显示详细的帮助信息。

## 🧪 测试流程

### 完整测试流程

1. **启动服务器**
   ```bash
   python3 simple_websocket_server.py
   ```

2. **启动客户端**（同事那边）
   ```bash
   python3 robot_test_client.py
   ```

3. **发送测试命令**
   ```
   1 open_door          # 测试开门
   1 close_door         # 测试关门
   1 start_delivery     # 测试开始配送
   1 stop_robot         # 测试停止
   ```

4. **观察响应**
   - 服务器端会显示命令发送状态
   - 客户端会显示接收到的命令并执行
   - 客户端会返回执行结果

### 测试结果示例

**服务器端输出**：
```
🤖 已连接的机器人: ['1']
请输入命令 (格式: 机器人ID 命令): 1 open_door
✅ 命令已发送: open_door -> 机器人 1
```

**客户端输出**：
```
📥 收到消息: command
🔧 收到命令: open_door
🔧 发送命令结果: success - 门已打开
```

## 🔧 高级功能

### 批量命令发送

可以连续发送多个命令：

```
1 open_door
1 start_delivery
1 stop_robot
1 close_door
```

### 多机器人控制

如果有多个机器人连接，可以分别控制：

```
1 open_door      # 控制机器人1
2 start_delivery # 控制机器人2
3 stop_robot     # 控制机器人3
```

### 自定义命令

如果需要添加新的命令类型，可以修改服务器代码中的命令处理逻辑。

## ❗ 注意事项

### 1. 连接状态

- 确保机器人客户端已连接
- 检查网络连接是否正常
- 确认服务器地址和端口正确

### 2. 命令格式

- 命令格式：`机器人ID 命令`
- 机器人ID必须是已连接的机器人
- 命令必须是预定义的有效命令

### 3. 错误处理

- 如果机器人未连接，会显示错误信息
- 如果命令格式错误，会提示重新输入
- 如果命令无效，会显示可用命令列表

### 4. 网络配置

- 确保防火墙允许WebSocket连接
- 检查端口8001是否被占用
- 确认服务器IP地址可访问

## 🔄 故障排除

### 常见问题

1. **命令发送失败**
   - 检查机器人是否已连接
   - 确认命令格式正确
   - 验证网络连接

2. **机器人无响应**
   - 检查客户端是否正常运行
   - 确认WebSocket连接状态
   - 查看客户端日志

3. **连接断开**
   - 检查网络稳定性
   - 确认服务器正常运行
   - 重新启动客户端

### 调试命令

```
help    # 显示帮助信息
status  # 查看机器人状态
quit    # 退出命令发送
```

## 📞 技术支持

如果遇到问题，请提供：
1. 错误信息截图
2. 服务器和客户端日志
3. 网络环境信息
4. 使用的命令和步骤

---

**状态**: ✅ 已完成并测试通过
**版本**: v1.0
**更新日期**: 2024-01-01 